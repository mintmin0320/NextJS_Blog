---
title: '자바스크립트 프로토타입 - 암기가 아닌 이해하기'
date: '2024-11-03'
tags: ['자바스크립트']
draft: false
summary: '자바스크립트가 프로토타입을 선택한 이유를 찾아보고 나의 생각 정리하기'
images: ['/static/images/thumbnail/prototype.webp']
---

<br />

<center>

> 이번 포스팅은 [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)를 읽고, <br/>
> 관련 내용을 쉽게 이해하고, 정리하기 위한 글입니다.

<br />

</center>

<hr />
<br />

<center>

> 프로토타입이란 무엇이라고 생각하시나요?

</center>

<br />

기술 면접 때, 위 질문을 대게 한 번쯤은 받아 본 경험이 있을 것이다. 나 역시 해당 질문을 받아 본 경험이 있었고, 여러 면접 예상 질문을 모아놓은 리스트에서도 빈출 질문으로 명시되어 있다.

면접을 앞두고 책, GPT, 답변 자료 등을 총합해 노션에 내가 답변할 해당 내용을 열심히 정리하고 외워서 면접을 봤다. 기계처럼, 습관처럼 말하기 위해 열심히 암기했다.

<br />

> 프로토타입은.. 자바스크립트에서 객체가 상속을 통해 다른 객체의 속성이나 메서드를 공유하는 기법으로..

<br />

면접이 끝나고 열심히 암기했던 프로토타입에 대한 기억은 따로 의식하지 않아도 자연스럽게 휘발되었다. 그렇게 다른 면접 날짜가 잡히게 되면, 나는 또다시 해당 내용을 기계처럼 암기하기 위해 노력했다.

지금까지 이 프로세스를 반복하며 이를 자각하지 못했다. 비단 프로토타입만의 문제가 아니라 대부분의 기술적인 내용을 암기하기에 급급했었던 것 같다. 그렇기 때문에 면접 때 긴장해서 해당 내용을 잊어버리거나, 응용되는 다른 질문을 받게 되면 쉽게 답변하지 못했다.

그래서 이번 기회를 계기로 <b>'프로토타입 원론'</b>과의 연관성을 통해 프로토타입을 더 쉽고 확실하게 이해하고 정리하는 시간을 가지고자 한다.

<hr />

## 프로토타입 기반 객체지향의 대척점 <br/> '클래스 기반 객체지향'

프로토타입 기반 객체지향과 클래스 기반 객체지향은 서로 대척점에 있다. 따라서 주요 원론을 비교해 보면 프로토타입을 더 쉽게 이해할 수 있다.

클래스 기반 객체지향 프로그래밍은 <b>추상적인 청사진(클래스)</b>을 이용해 구체적인 <b>실체(객체)</b>를 만드는 방식이다. 이 과정에서 클래스는 객체의 설계도 역할을 하며, <b>객체는 이 설계도를 바탕으로 만들어진다.</b>

이해를 돕기 위해 <b>라면</b>을 예로 들어보자.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/1951e6ff-05c3-4c32-95d1-8102c38bd825/image.png)

</center>

마트에서 라면을 살 때 우리는 <b>'라면'</b>이라는 <b>추상적인 개념</b>을 사는 것이 아니라 <b>'신라면'</b>이나 <b>'오징어짬뽕'</b> 같은 라면의 한 종류를 산다. 여기서 '라면'이라는 개념은 <b>다양한 속성</b>과 <b>공통적인 조리 과정</b>을 공유하는 <b>추상적인 클래스와 같고</b>, 실제로 구매하는 것은 신라면이나 오징어짬뽕 같은 <b>구체적인 객체</b>이다.

클래스 기반 객체지향의 대표적인 언어 중 하나로 <b>Java</b>가 있다. Java는 클래스를 사용하여 객체를 생성하고, 이를 통해 객체지향 프로그래밍의 주요 개념인 <b>상속, 다형성, 캡슐화</b>를 명확하게 구현할 수 있는 특징을 가지고 있다.

```
abstract class Ramen {
    String name;

    // 라면 끓이는 과정 (공통 메소드)
    public void cookRamen() {
        cook();
        serve();
    }

    // 기본적인 조리 과정
    private void cook() {
        System.out.println("물을 끓이고 라면 사리를 넣습니다.");
        System.out.println("건더기 스프를 넣습니다.");
    }

    private void serve() {
        System.out.println(name + " 완성되었습니다. 맛있게 드세요!\n");
    }
}

class ShinRamen extends Ramen {
    public ShinRamen() {
        this.name = "신라면";
    }
}

public class Main {
    public static void main(String[] args) {
        Ramen ramen = new ShinRamen();
        ramen.cookRamen();
    }
}

```

라면의 예시를 Java로 구현하면, 우리가 흔히 접할 수 있는 클래스와 객체의 관계를 직관적으로 이해할 수 있는 간단한 코드가 된다.

프로토타입과 동일하게 클래스 기반 객체지향 또한 주요 원론이 존재하는데, 학창 시절 윤리와 사상을 배워봤다면 한 번쯤은 들어봤을 <b>플라톤, 아리스토텔레스의 이론</b>이다.

<hr />

## 플라톤의 이데아론

추상적인 대상을 실체화하는 이 개념은 플라톤의 이데아 이론과 유사한데, 플라톤은 <b>본질적이지만 추상적인 개념은 현실에 존재하지 않는다</b>고 주장했다. 그렇기 때문에 <b>우리가 만나는 것은 항상 구체적인 형태로만 존재</b>한다는 것이다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/d75b8b3b-9b46-411f-ab6f-161bc2dc7349/image.png)

### < 플라톤 - 이데아론을 동굴에 비유 >

#### 세상 만물은 동굴 벽에 비친 그림자에 불과하고 동굴 밖에 실체가 존재하며, <br/> 인간은 그 실체를 보아야 한다는 주장

</center>

<br />

이와 같은 추상적인 개념은 객체지향 프로그래밍의 클래스와 유사하다. 클래스는 <b>어떤 대상의 본질적인 속성을 정의하지만, 구체적인 실체는 아니다.</b> 즉, '라면'이라는 클래스는 ‘이름, 가격, 칼로리’와 같은 라면의 <b>본질적인 속성을 정의할 뿐, 직접 존재하는 것은 아니다.</b>

<hr />

## 아리스토텔레스 - 분류

플라톤의 제자인 아리스토텔레스는 이를 이어받아, <b>동일한 속성을 가진 개체들을 묶어 범주화하는 개념</b>으로 발전시켰다. 아리스토텔레스는 '라면'이라는 본질적인 속성을 가진 여러 개체들이 존재할 수 있다고 보았고, 이러한 개체들을 <b>분류</b>하는 개념을 발전시켰다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/f2547cd1-c9d3-4b74-9939-e6c39c912e20/image.png)

#### 아리스토텔레스는 분리수거에 상당히 능했을 것이다. ( 추정 )

</center>

<br />

이는 객체지향 프로그래밍에서 <b>클래스 기반의 분류 체계</b>로 정착되었으며, 동일한 클래스를 기반으로 (신라면, 오징어 짬뽕과 같은) 다양한 인스턴스를 만들 수 있다.

따라서, 객체지향 프로그래밍에서 <b>클래스는 플라톤의 이데아와 같은 추상적 존재로, 인스턴스는 아리스토텔레스의 분류된 실체</b>와 같다고 볼 수 있다. 이러한 철학적 개념이 현재의 클래스 기반 객체지향 프로그래밍에 영향을 미친 것이다.

<hr />

## 프로토타입 기반 객체지향은 <br/> 의미사용, 가족유사성 이론의 어떤 점을 착안했나

의미사용, 가족유사성 이론은 프로토타입 기반 객체지향의 특정 개념을 대표하는 전형적인 예시로 기능하며, 이 전형적인 예시는 새로운 객체를 생성하는 데 사용된다. 이 두 가지 주요 원론을 이해하면 프로토타입의 동작 방식과 개념을 깊이 이해하는 데 큰 도움이 된다.

<br />

## 의미사용 이론

<center>

> 객체들은 특정 의미나 역할에 따라 사용되며, <br/> 그 의미가 상황에 따라 달라질 수 있다.

- 특정 객체가 사용되는 맥락에 따라 새로운 역할을 부여받아 다양한 의미를 가질 수 있다.

![](https://velog.velcdn.com/images/mintmin0320/post/e90305c5-323d-4a28-95fe-08b0d3e28240/image.png)

</center>

파리채는 원래 벌레를 잡는 용도로 만들어진 도구지만, <b>상황에 따라 파리채는 다른 의미를 가질 수 있다.</b> 예를 들어, 훈육의 상징적 도구로 사용되기도 하며, 신체에서 손이 닿지 않는 곳을 긁을 때에도 사용될 수 있다. 이처럼 파리채라는 객체는 원래 용도인 '벌레 잡기' 외에도 여러 <b>상황에서 다양하게 재해석</b>될 수 있다.

<br />

## 프로토타입 기반 객체지향 프로그래밍에서의 활용

이 방식은 프로토타입 기반 객체지향 프로그래밍에서 <b>객체들이 상황과 맥락에 따라 새로운 의미와 역할을 유연</b>하게 취할 수 있게 하는 핵심 개념과 연결된다.

의미사용 <b>이론은 고정된 클래스 구조에 얽매이지 않고, 객체가 상황에 따라 역할을 변경할 수 있다는 점</b>에서 프로토타입 기반 객체지향 프로그래밍과 잘 맞아떨어진다. 프로토타입 기반에서는 공통된 프로토타입을 통해 <b>동일한 기능이나 메서드를 공유하면서도, 객체가 각기 다른 상황에서 새로운 역할</b>을 가질 수 있는 `유연한 구조`를 제공한다.

앞서 예로 들었던 파리채처럼, 여러 상황에서 프로토타입을 기반으로 다양한 역할을 수행하는 인스턴스가 만들어질 수 있다. 이는 <b>코드 중복을 줄이고, 확장성과 유연성을 극대화</b>한다.

<br />

## 가족 유사성 이론

<center>

> 가족 구성원들이 서로 다른 외모적 특징을 가진다고 해도, <br/> 여전히 그들은 '가족'이라는 범주로 묶인다.

- 객체들이 공통적인 특징을 가지고 있으나 <br/> 그 특징이 모두에게 동일하게 적용되지 않을 수 있다.

![](https://velog.velcdn.com/images/mintmin0320/post/e843ac72-0ffd-4b08-8493-c194a7f54429/image.png)

</center>

가족 유사성 이론에 대한 이해를 돕기 위해 강아지와 CCTV를 살펴보자. 공통적인 속성을 찾기 위해 고민했지만, 쉽게 공통점을 찾을 수 없을 것이다. 여기서 필자는 <b>'집을 지킨다'라는 공통점</b>을 생각해 냈다. 그렇다면 이제 강아지와 CCTV는 <b>'집을 지킨다'</b>라는 `같은 범주`로 묶을 수 있게 되었다.

이러한 예시는 가족 유사성 이론의 핵심인 <b>서로 다른 외형과 본질을 지녔더라도 특정 역할이나 기능을 공유하여 하나의 그룹으로 묶일 수 있다는 개념</b>을 잘 보여준다.

<br />

## 프로토타입 기반 객체지향 프로그래밍에서의 활용

이와 같은 방식은 프로토타입 기반 객체지향 프로그래밍에서 <b>객체들이 특정 상위 개념에 엄격하게 종속되지 않으면서</b>도 <b>유사성을 기반으로 그룹화</b>할 수 있는 장점과 연결된다. <b>각 객체가 동일한 상위 클래스를 통해 생성되지 않았더라도, 일부 공통된 메서드나 속성을 프로토타입을 통해 공유함으로써 가족(그룹)으로 묶일 수 있다.</b>

이를 통해 <b>코드 중복을 줄이고 재사용성을 높이며 확장 가능성을 확보</b>할 수 있게 한다. 다양한 객체들이 하나의 공통 프로토타입을 사용하여 유사성을 공유하면서도 각자의 독립적인 속성을 유지할 수 있어, 객체가 특정 상황이나 맥락에 따라 새로운 의미나 역할을 유연하게 취할 수 있다.

이로써 가족 유사성 이론은 객체지향 프로그래밍에서 <b>객체의 유연한 그룹화</b>와 <b>공통 기능의 공유 가능성</b>을 설명하는 좋은 예가 된다는 것을 알 수 있다.

<hr />

두 이론을 살펴보면, 공통적으로 유연하고 동적인 부분이 강조되는 것을 알 수 있다. 따라서 유연하고 동적인 부분이 자바스크립트가 프로토타입 기반을 선택한 이유라고 추측할 수 있지만, 여전히 <b>'왜 유연하고 동적이어야 하는지'</b>에 대한 궁금증이 남게 된다.

답을 찾기 위해서는 자바스크립트가 <b>탄생</b>한 이유를 생각해 볼 필요가 있다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/157e2c17-71c9-48e3-bb2a-879cd5483bdc/image.png)

</center>

## 왜 자바스크립트는 프로토타입 기반 객체지향을 선택했나

앞서 클래스 기반의 코드와 다르게 변경/추가 등의 작업이 유연하게 동적으로 작용하고 있다. 이 유연함은 큰 장점이지만, <b>동시에 예측하기 어려운 불안정한 구조</b>라고 볼 수도 있다. 왜 안정적인 클래스 기반 객체지향을 따라가지 않고 유연하지만 자칫 불안할 수도 있는 프로토타입 기반 객체지향 구조를 선택했을까?

자바스크립트의 탄생은 <b>정적인 웹페이지에서 생동감을 붙여넣기 위해</b>서였다. 즉, 자바스크립트는 <b>브라우저에서만 쓸 목적</b>으로 고안된 언어로 시작된 언어였다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/a3f5c6d3-30b5-4de4-be3b-9049de0cefa2/image.png)

####

</center>

따라서 자바스크립트는 <b>유연성과 동적 특성을 중요시한 브라우저 환경에서 상호작용을 빠르게 처리하고 변화에 즉각적으로 대응</b>해야 했고, 이 때문에 가장 적합한 프로토타입을 선택하게 된 것이다. 이 선택 덕분에 자바스크립트는 <b>사용자와의 실시간 상호작용</b>을 원활하게 지원하며, 현대 웹의 핵심 요소로 자리 잡게 되었다.

비록 프로토타입 기반의 유연성이 <b>예측하기 어려운 상속 관계</b>를 초래할 수 있는 단점도 있지만, 이러한 동적 특성 덕분에 브라우저와 서버 환경 모두에서 <b>확장성</b>과 <b>실시간성</b>을 가진 언어로 발전할 수 있었다.

<hr />

## 프로토타입 코드로 살펴보기

프로토타입의 동적인 유연함을 강조하는 이론을 알아봤으니, 이번에는 코드와 함께 프로토타입의 유연성을 살펴보기 위해 <b>라면</b>에서 <b>인스턴트</b>로 프로토타입을 변경해 보자.

```
function 라면(name) {
  this.name = name;
}

const 신라면 = new 라면("신라면");
const 오징어_짬뽕 = new 라면("오징어 짬뽕");
const 짜파구리 = new 라면("짜파구리");

// 라면 -> 인스턴트 변경
function 인스턴트(name) {
  this.name = name;
}

// 라면 생성자의 프로토타입을 인스턴트 프로토타입으로 변경
Object.setPrototypeOf(라면.prototype, 인스턴트.prototype);

인스턴트.prototype.추가된_자기소개 = function () {
  console.log(`나는 맛있는 ${this.name}`);
};

신라면.추가된_자기소개(); // "나는 맛있는 신라면"
오징어_짬뽕.추가된_자기소개(); // "나는 맛있는 오징어 짬뽕"
짜파구리.추가된_자기소개(); // "나는 맛있는 짜파구리"
```

만약 클래스 기반에서 라면을 인스턴스로 변경했을 경우 <b>인스턴스를 재정의</b> 해야 하는 소요가 발생한다. 하지만, 자바스크립트 프로토타입에서는 메서드를 추가한 뒤에 신라면, 오징어 짬뽕, 짜파구리의 상위 프로토타입을 라면에서 인스턴트로 변경하는 동작만으로 인스턴스를 재정의 하지 않고 변경사항을 구현할 수 있다.

<br />

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/acccb73e-6f23-4781-89ed-5278fe226841/image.png)

</center>

내부적으로는 `new`키워드를 통해 생성된 신라면 함수 내부에는 자동으로 `__proto__` 프로퍼티가 생성된다. 그리고 생성자 함수의 프로퍼티인 `prototype`을 <b>복사</b>하게 되고 링크가 연결된다.

그리고 라면에서 인스턴트로 변경됐을 때 모든 라면 인스턴스(신라면, 오징어 짬뽕, 짜파구리)의 `__proto__`의 체인 상에서 `인스턴트.prototype 프로퍼티`를 가리키게 변경된다.

이렇듯, 내부적으로 마치 연결된 체인이 상황에 따라 연결된 상태를 변경하는 모습을 보이게 된다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/dbf770d8-9161-4822-8866-f22cdec036c8/image.png)

</center>

상위 영역 프로토타입이 라면에서 인스턴트로 변경됐지만, 신라면(인스턴스)의 입장에서 이 변경은 라면과의 체인 연결을 끊고 인스턴트와 체인을 연결하기만 하면 된다. 이러한 변경은 자바스크립트의 객체가 프로토타입을 통해 <b>상속 구조</b>를 가지면서도 <b>유연하게 변할 수 있음</b>을 잘 보여준다.

자바스크립트에서 객체의 프로토타입 체인은 상황에 따라 동적으로 상속 체계를 조정할 수 있기 때문에, 개발자는 필요에 따라 객체의 특성을 추가하거나 변경할 수 있는 강력한 유연성을 갖게 된다.

<hr />

## prototype = ( 명사 ) 원형

각 객체들은 상위의 프로토타입과 연결되고, 또 상위의 프로토타입과 연결될 수 있다. 이렇게 체인이 상위로 연결되다 보면, 프로토타입은 그 의미에 걸맞게 <b>여러 계층을 가지는 원형 구조</b>가 된다.

이 원형 구조는 <b>객체 간의 속성</b>과 <b>메서드를 상속</b>할 수 있는 강력한 메커니즘으로 작용하며, <b>모든 객체가 서로 연결된 네트워크 형태</b>를 이루게 된다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/234b9938-8733-4fd9-9dd6-a3c40f4e0756/image.png)

</center>

이러한 계층적인 원형 구조와 그 속에 있는 각각의 원(객체) 간의 관계를 살펴보면, 자바스크립트에서 자주 언급되는 <b>실행 컨텍스트</b>, <b>렉시컬 스코프</b>, <b>호이스팅</b>, <b>this 동작 원리</b>를 이해하는데 큰 도움이 된다.

<hr />

## 실행 컨텍스트, 렉시컬(정적) 스코프와 프로토타입

실행 컨텍스트는 함수가 호출될 때마다 생성되며, 해당 코드를 실행하는 데 필요한 모든 정보가 저장된다. 이때 객체가 어떤 속성이나 메서드를 찾을 때, 자바스크립트 엔진은 <b>해당 객체의 스코프 영역</b> 내에서 먼저 찾고, 만약 없다면 <b>프로토타입 체인을 따라 상위 객체</b>에서 찾게 된다.

그리고 실행 컨텍스트 내의 렉시컬(정적) 스코프는 실행 컨텍스트가 생성될 때, <b>내부에 선언된 변수와 함수를 실행 컨텍스트 최상단으로 호이스팅</b>하게 되는데, <b>함수가 호출된 시점이 아닌 함수가 정의된 시점에서의 상위 스코프를 기준으로 변수 접근 범위를 결정</b>하고 스코프를 고정한다.

반면, 프로토타입 체인은 실행 시점에서 동적으로 상위 객체를 찾아가며 동작하게 된다. 그렇다면 왜 렉시컬 스코프는 프로토타입처럼 동적으로 변경되지 않고 정적으로 고정될까?

만약 렉시컬 스코프가 동적으로 결정된다고 가정해보자.

```
let greeting = "Hello, World!";

function sayHello() {
  console.log(greeting);
}

function setNewGreeting() {
  let greeting = "Hello, JavaScript!"; // 새로운 greeting 정의
  sayHello(); // sayHello()를 호출
}

sayHello(); // 예상 결과: "Hello, World!"
setNewGreeting(); // 예상 결과는 무엇일까?
```

위 코드를 보고 결과를 예측해보자. `sayHello()`의 결과는 쉽게 예측할 수 있는 `Hello, World!`가 출력될 것이다. 이제 `setNewGreeting()`가 렉시컬(정적) 스코프일 때, 동적 스코프 일 때를 비교해보자.

<br />

### 렉시컬(정적) 스코프로 동작하면?

`sayHello()` 함수는 정의된 위치에서의 스코프를 참조해 `sayHello()` 함수가 호출될 때 전역으로 정의된 `greeting`의 값 `"Hello, JavaScript!"`을 출력하게 될 것이다.

### 동적 스코프로 동작하면?

상위의 프로토타입 체인이 변경됐다고 가정했을 때, 이제 `sayHello()`는 <b>호출된 위치에 따라 참조하는 스코프가 동적으로 변경되게 된다.</b> 즉, `setNewGreeting()` 함수 내에서 `sayHello()`를 호출하게 되면, 그 호출 위치에 따라 `setNewGreeting()` 함수 내부의 지역 변수 `greeting`을 참조하게 될 수 있다. 이로 인해 결과는 `"Hello, JavaScript!"`가 출력될 것이다.

<br />

## 무엇이 문제가 될까?

### - 의도치 않은 참조 변화

개발자는 `sayHello()` 함수가 항상 전역의 `greeting`을 참조할 것이라고 생각하고 작성했지만, 동적 스코프라면 호출 위치에 따라 다른 변수를 참조하게 된다.

즉 <b>환경에 따라 동일한 함수 호출이 다른 결과</b>를 얻게 된다. 이는 개발자 입장에서 <b>함수의 동작을 예측</b>하기 어렵고 <b>코드의 일관성</b>이 떨어지기 때문에 <b>개발 및 유지 보수 과정</b>에서 어려움이 발생할 것이다.

<br />

### - 클로저는 더이상 사용이 불가능하다.

클로저는 <b>함수가 정의될 때의 렉시컬 환경을 캡처</b>하기 때문에 <b>함수 외부에서 정의된 변수를 참조</b>할 수 있게 된다. 하지만, 정의된 환경에 따라 동작하게 될 경우 클러저의 상태 유지를 통한 일관된 참조가 무력화 된다.

당장 우리가 많이 사용하는 React에서의 hook 관리에서도 지장이 생기고, 자바스크립트의 많은 기능을 사용하지 못하게 될 것이다.

<br />

자바스크립트의 프로토타입은 객체 간 상호 연결된 체인 구조를 통해 매우 동적인 특성을 지니게 된다. 반면, 렉시컬 스코프가 <b>정적 스코프</b>를 참조함으로써 <b>함수 내부 동작에서의 일관성과 예측 가능성을 보장</b>하고, 이를 통해 <b>코드의 안정성을 부여</b>하게 되는 상호 보완적인 역할을 수행하게 된다.

이제 우리는 이렇게 그동안 정적 스코프라고 불렀던 렉시컬 스코프가 왜 정적 스코프인지 이해할 수 있게 되었다.

<hr />

## this와 프로토타입

this는 렉시컬(정적) 스코프와 대비되는 특성을 가지고 있으며, <b>동적</b>으로 호출되는 방식과 시점에 따라 그 값이 결정된다.

자바스크립트에서 함수나 스크립트가 실행될 때마다 실행 컨텍스트가 생성되고, 이 <b>실행 컨텍스트가 활성화되면서 this 바인딩이 이루어지게 된다.</b> 이때 자바스크립트 엔진은 <b>함수가 어떤 방식으로 호출되었는지</b>를 기준으로 this를 바인딩한다. (예를 들어, 일반 함수 호출, 메서드 호출, 생성자 호출 등)

프로토타입은 동적으로 결정되는 구조다. 즉, 스코프 체인을 따라가며 연결된 객체들을 탐색하는 과정에서 동적인 호출자가 등장할 수 있으며, 이는 언제든지 변할 수 있다. 이러한 특성 때문에, <b>this 역시 고정된 렉시컬 스코프와 달리 동적으로 변화할 수 있는 메커니즘을 필요로 하게 된 것이다.</b> 이는 this가 <b>함수가 호출되는 맥락에 따라 값을 가질 수 있도록 설계된 이유</b>이기도 하다.

결국, 자바스크립트의 프로토타입 체인과 this 바인딩은 모두 동적인 특성 덕분에, <b>객체나 함수 호출 시점에서의 유연한 동작을 가능</b>하게 하여 복잡하고 다양한 상호작용을 실현할 수 있게되는 것이다.

<br />

만약 this가 정적으로 동작한다면?

```
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name}는 소리를 낸다.`);
};

const dog = new Animal('강아지');
const cat = new Animal('고양이');

dog.speak(); // "개는 소리를 낸다."
cat.speak(); // "고양이는 소리를 낸다."
```

우리는 당연하게 결과를 예상하지만 this가 정적으로 동작한다면,

```
dog.speak(); // "개는 소리를 낸다."
cat.speak(); // "고양이는 소리를 낸다."
```

`speak` 함수의 this가 정적으로 `Animal.prototype`에 고정됐기 때문에 위 결과가 아닌 아래와 같은 결과가 출력됐을 것이다.

```
dog.speak(); // "undefined는 소리를 낸다."
cat.speak(); // "undefined는 소리를 낸다."
```

this가 정적으로 동작하게 되면, 함수가 어디서 호출되든지 간에 항상 같은 객체를 참조하게 되고 이는 프로토타입 기반 자바스크립트의 장점인 코드 유연성과 재사용성을 떨어뜨리게 된다.

<hr />

## 프로토타입을 이해하는 답은 프로토타입(원형)이었다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/0ad22b2f-f908-4215-aac8-a3acb647f2e7/image.png)

</center>

새와 관련된 원형 구조처럼 보이지만, <b>언제든지 상황과 맥락에 따라서 펭귄이 연결될 수도 있고, 라면 혹은 강아지 연결될 수도 있다.</b> 글을 마치는 지금, 이제는 이러한 원형 구조와 프로토타입, 실행 컨텍스트, this, 렉시컬 스코프를 이해하고 <b>"자바스크립트는 왜 프로토타입을 선택했는지"</b>에 대한 답변을 자신있게 할 수 있을 것 같다.

<br />

<center>

> 결국 답은 프로토타입에 있었다..!

</center>

<br />
<hr />

## 글을 마치며

이번 글은 "자바스크립트는 왜 프로토타입을 선택했는지?"에 대한 질문에서부터 시작되었는데, 사실 이전까지 프로토타입은 나에게 기술 면접 단골 출제 개념 정도의 인식이 강했고, 특별하게 의식했던 존재는 아니었다. 하지만 이번 글을 작성하며 아직 나의 학습이 많이 부족했다는 반성을 하게 되었다.

<center>

![](https://velog.velcdn.com/images/mintmin0320/post/b2c353fc-f2dc-422a-90e3-c7ef8d0ed1f2/image.png)

</center>

특히 이번에 클래스, 프로토타입 기반 객체지향의 원론을 비교한 부분이 정말 흥미롭고 유익하게 느껴졌는데, 참고 글을 읽고 나만의 방식으로 쉽게 정리해 기록하고 언젠가 내가 프로토타입과 관련된 기억을 망각하게 됐을 때를 대비해 글을 작성하게 되었다.

프로토타입뿐만 아니라 최근에 React의 useState, Promise, Closure를 Vanilla JS로 직접 구현하고 학습하며 어렵고 어색하게만 느껴졌던 자바스크립트의 이론적인 개념들을 하나둘씩 이해하게 됐고, 더 가깝게 느껴지기 시작했다. 앞으로도 마냥 단순하게 암기하는 것보다 기억, 성장에 더 도움이 되는 효율적인 이해 -> 암기 -> 적용(활용) 단계를 걷기 위해 노력하자.

<br />

<center>

> 잘못된 내용이 있다면 언제든 피드백 환영입니다~ 🙇🏻‍♂️

</center>

<br />
<hr />

# Reference

- [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)

- [파리채 이미지](https://prod.danawa.com/info/?pcode=11274075), [js vs ts 이미지](https://www.instagram.com/waterglasstoon/), [동굴의 우화 이미지](https://ko.wikipedia.org/wiki/%EB%8F%99%EA%B5%B4%EC%9D%98_%EC%9A%B0%ED%99%94), [원형 이미지](https://laurabecker.gitlab.io/classes/as/08-semantics.pdf)

- 모던 자바스크립트 Deep Dive, 코어 자바스크립트
